# JOHNSON COUNTER
A Johnson counter is a modified ring counter in which the output from the last flip flop is inverted and fed back as an input to the first. It is also called as Inverse Feedback COunter or Twisted Ring Counter. It is used in hardware logic design to create complicated Finite States Machine (FSM) eg: ASIC and FPGA design. It roughly consumes 80-100 mW of power and runs at a clock frequency of 36 MHz.

## BLOCK DIAGRAM OF JOHNSON'S COUNTER

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/d5d4184f-0c81-493c-84ea-02a67d95613b)

## aplication of johnson counter
 * Used as a synchronous decade counter or divider circuit.
 * 3 stage Johnson counter is used as a 3 phase square wave generator with 1200 phase shift.

## required tools
 * iverilog -> Icarus Verilog is an open source Verilog compiler that supports the IEEE-1364 Verilog HDL including IEEE1364-2005 plus extensions.
 * Yosys -> Yosys is a framework for Verilog RTL synthesis. It currently has extensive Verilog-2005 support and provides a basic set of synthesis algorithms for various application domains.
 * Gtkwave -> GTKWave is a fully featured GTK+ based wave viewer for Unix and Win32 which reads LXT, LXT2, VZT, FST, and GHW files as well as standard Verilog VCD/EVCD files and allows their viewing.

## FUNCTIONAL SIMULATION

#### About iverilog and gtkwave
Icarus Verilog is an implementation of the Verilog hardware description language.
GTKWave is a fully featured GTK+ v1. 2 based wave viewer for Unix and Win32 which reads Ver Structural Verilog Compiler generated AET files as well as standard Verilog VCD/EVCD files and allows their viewing.

#### Installing iverilog and gtkwave in Ubuntu
Open your terminal and type the following to install iverilog and GTKWave

    $   sudo apt get update
    $   sudo apt get install iverilog gtkwave

* To clone the repository and download the netlist files for simulation , enter the following commands in your terminal.

      $   git clone https://github.com/Shubhashree359/johnson_counter.git
      $   cd johnson_counter

* To simulate and run the verilog code , enter the following commands in your terminal.

      $   iverilog pes_johnson_counter.v pes_johnson_counter_tb.v -o pes_johnson_counter
      $   ./pes_johnson_counter
    
* To see the output waveform in gtkwave, enter the following commands in your terminal.

      $   gtkwave pes_johnson_counter.vcd

#### The output waveform

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/41bf9287-56a0-4ad7-bc33-625a65a796cc)

## Synthesis
Synthesis transforms the simple RTL design into a gate-level netlist with all the constraints as specified by the designer. In simple language, Synthesis is a process that converts the abstract form of design to a properly implemented chip in terms of logic gates.

Synthesis takes place in multiple steps:

 * Converting RTL into simple logic gates.
 * Mapping those gates to actual technology-dependent logic gates available in the technology libraries.
 * Optimizing the mapped netlist keeping the constraints set by the designer intact.

#### GLS(gate level synthesis)
 While performing GLS(gate level synthesis) we use skywater 130 nm technology library files to import the cells from the library. Using those cells we then generate the netlist which would be a new .v file generated by write_verilog command. With this file and the testbench we generated for the RTL simulation we would again get a new waveform for this GLS netlist. This waveform should match with our initial waveform, infact waveforms if every stages of the flow should match the initial design waveform.

### Yosys Synthesizer:
It is a tool we use to convert out RTL design code to netlist. Yosys is the tool I've used in this project.

The commands to get the yosys is given below:

 * Go to the directory where verilog file is present and open terminal
 * invoke Yosys

Now you need to create a yosys_run.sh file , which is the yosys script file used to run the synthesis. The contents of the yosys_run file are given below:

    yosys>read_liberty -lib /home/vsd/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib
    yosys>read_verilog pes_johnson_counter.v
    yosys>synth -top pes_johnson_counter

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/5a035cb7-741a-4e97-a466-a10a07890fb1)

    yosys>abc -liberty /home/vsd/VLSI/sky130RTLDesignAndSynthesisWorkshop/lib/sky130_fd_sc_hd__tt_025C_1v80.lib

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/1758fe61-7113-40c5-ae03-9344466d223d)

    yosys>flatten
    yosys> show
    yosys> write_verilog -noattr pes_linearfsr_net.v

  ![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/55ec160c-4146-4c94-afc2-9d221474853c)

 #### * invoke GLS

    iverilog /home/vsd/VLSI/sky130RTLDesignAndSynthesisWorkshop/my_lib/verilog_model/primitives.v /home/vsd/VLSI/sky130RTLDesignAndSynthesisWorkshop/my_lib/verilog_model/sky130_fd_sc_hd.v pes_pwm_gen_netlist.v pes_pwm_gen.v
    ./a.out
    gtkwave pes_linearfsr_tb.vcd

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/5c35faa1-d30a-464b-8517-af505539098e)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/4c3255f1-7bb4-4064-968a-2d2dafed3c96)

#  PHYSICAL DESIGN

 ## Openlane
OpenLane is an automated RTL to GDSII flow based on several components including OpenROAD, Yosys, Magic, Netgen, CVC, SPEF-Extractor, CU-GR, Klayout and a number of custom scripts for design exploration and optimization. The flow performs full ASIC implementation steps from RTL all the way down to GDSII

### Openlane FLow

### 1. Automation

 * Speed and Efficiency: Automated OpenLane flow is designed for speed and efficiency. It can quickly generate a complete ASIC design without the need for much user intervention.
 * Batch Processing: It is well-suited for batch processing where you have a large number of similar designs or you want to quickly evaluate multiple design options.
 * Scriptable and Reproducible: The flow can be scripted, making it suitable for running on large clusters or cloud-based infrastructure, and it ensures reproducible results.
 * Minimal User Expertise: You do not need in-depth expertise in ASIC design to run the automated flow, making it accessible to a wider range of users.
 * Default Configuration: It typically relies on a default configuration and a pre-defined set of tools and options, which simplifies the process but may not be optimized for specific custom requirements.

### 2. Interactive

 * Customization: The interactive OpenLane flow allows users to have more control and customization over the design process. You can fine-tune parameters, specify custom design rules, and make changes at different stages of the flow.
 * Optimization: Users can optimize the design for specific performance, power, or area requirements by adjusting various design parameters and choices.
 * Debugging and Troubleshooting: When issues or design challenges arise, the interactive flow provides a way to interactively diagnose and resolve them, allowing for more in-depth analysis.
 * Design Exploration: It is suitable for design exploration, where designers want to experiment with different design options and evaluate their impact on the final result.
 * Expertise Required: Using the interactive flow requires a higher level of expertise in ASIC design, as it involves more manual intervention and decision-making

First we create a folder under the name of our design in the 'designs' folder.
    
     cd pes_johnson_counter
    
then we create a config.json file.
We make a new directory called 'src' using:

     cd src
    
We add the following files to this directory.

All these files are found above in the 'pes_johnson_counter' folder.

Now in the main 'Openlane' directory type         mkdir pdks

Copy paste the         .v     file in it. Found in the verilog_model folder above.

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/3d261c75-c561-4e8c-bbff-ded8fd15ed5a)

### 1. Automatic flow openlane

    cd OpenLane
    sudo make mount
    ./flow.tcl -design PES_freqdiv
    
![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/f3df8d49-f3ff-45e6-8a7c-182ac12c47fb)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/d09afad6-ba4a-4698-8d39-1be81649876b)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/86a1c5ae-e076-4724-b079-29b7a992167b)

### 2. Interactive flow openlane

    cd OpenLane
    sudo make mount
    ./flow.tcl -interactive
    package reuire opanlane
    prep -design PES_freqdiv

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/eb854f2f-3880-4db7-8b2f-ed7ea480c9de)

### synthesis 
Synthesis is the process of creating a gate level description of the blocks that are described behaviorally in verilog and prepairing the complete design for the place and route process.

command for synthesis:

    run_synthesis    

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/9e3e7aff-eb32-4037-92ab-863cd3a0d7a4)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/460797cb-1216-41ef-9f63-9e0f22211a8e)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/5a396fde-f7f5-4f48-a565-3fb685fc7367)

#### Calculating Flop Ratio


Flop ratio = Number of D Flip flops / Total Number of cells

Flop Ratio = 8/9 = 0.889

### Floorplan
Physical design is process of transforming netlist into layout which is manufacture-able [GDS]. Physical design process is often referred as PnR (Place and Route) / APR (Automatic Place & Route). Main steps in physical design are placement of all logical cells, clock tree synthesis & routing. During this process of physical design timing, power, design & technology constraints have to be met. Further design might require being optimized w.r.t area, power and performance

Now to invoke the floorplan we type

    run_floorplan

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/e3b1d68d-737a-4af9-9dd1-47da84f0482d)

Post the floorplan run, a .def file will have been created within the results/floorplan directory. We may review floorplan files by checking the floorplan.tcl. The system defaults will have been overriden by switches set in conifg.tcl and further overriden by switches set in sky130A_sky130_fd_sc_hd_config.tcl.

die area 

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/01eafa66-c540-403d-a6b8-5a4c2d38f57d)

core area 

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/076225ab-5eb9-4a65-ac0c-f79f2531883d)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/20c8cd0d-14bb-4fbe-8e3a-b7bf06cbdfaa)

To view the design we type

    magic -T /home/vsd/VLSI/OpenLane/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.nom.lef def pes_ripco.def &

### Magic output:

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/c12165cd-bec2-491a-9b60-dcff7c7a1831)

* One can zoom into Magic layout by selecting an area with left and right mouse click followed by pressing "z" key.
* Various components can be identified by using the what command in tkcon window after making a selection on the component.
* Zooming in also provides a view of decaps present in johnson's counter chip.
* The standard cell can be found at the bottom left corner.

### Placement
Placement can be done in four phases:

#### Pre-placement optimization:
In this process optimization happens before netlist is placed. In this process high-fan out nets are collapsed downsizing the cells.

#### In placement optimization: 
In this process logic is re-optimized according to the VR. Cell bypassing, cell moving, gate duplication, buffer insertion, etc. can be performed in this step.

#### Post Placement optimization: 
Netlist is optimized with ideal clocks before CTS. It can fix setup, hold violations. Optimization is done based on global routing.

#### Post placement optimization after CTS optimization: 
Optimization is performed after the CTS optimization is done using propagated clock. It tries to preserve the clock skew.

Invoke placement using command: 
    
    run_placement

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/d841af37-ba7a-4adf-9706-1e1ddc6426be)

to see the design 

    magic -T /home/vsd/VLSI/OpenLane/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.nom.lef def pes_ripco.def &

#### Magic output:

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/5cee7de7-f230-4f27-918e-60b64c77070f)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/d3ed191a-2977-458f-a599-6ed369659d22)

### Clock Tree Synthesis (CTS):

The purpose of building a clock tree is enable the clock input to reach every element and to ensure a zero clock skew. H-tree is a common methodology followed in CTS. Before attempting a CTS run in TritonCTS tool, if the slack was attempted to be reduced in previous run, the netlist may have gotten modified by cell replacement techniques. Therefore, the verilog file needs to be modified using the write_verilog command. Then, the synthesis, floorplan and placement is run again. To run CTS use the below command:

    run_cts

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/1c660da1-eff9-4489-8e40-e6ecd46fe1f4)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/e5697ab6-58ea-458d-a48c-1c58390c074c)

#### Magic output:

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/dbb3914b-3e52-46ca-819a-8ae57f40da41)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/073c54ff-ced5-44b5-9c19-482fb3859c34)

### Routing
The overall routing job is executed in three steps which are

#### Global Routing :
In this stage, the whole design is first partitioned in small routing region into tiles/rectangles. Also, region to region paths are decided in a way to optimize the wire lengths and timing. This stage is actually the planning stage and no actual routing is done.

#### Track Assignment:
In this stage, the routing tracks assigned by the global stage are replaced by the metal layers. Tracks are assigned in horizontal and vertical direction. If overlapping is occurred then rerouting is done.

#### Detailed Routing: 
Even if the metal layers are laid, the path may exists which can violate the setup and hold criteria In this stage, the critical paths are searched and fixed in many iterations until fixed.

Write the command to run routing:

    run_routing

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/bb82e637-5e2f-4108-a8b4-302650697beb)

To see the design:
    
    magic -T /home/vsd/VLSI/OpenLane/pdks/sky130A/libs.tech/magic/sky130A.tech lef read ../../tmp/merged.nom.lef def pes_ripco.def &
    
#### Magic output:

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/58d24ccc-062d-4d9a-978e-f4ae268c038d)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/2755017b-54c5-4afb-b2de-5aad8d4b9ec3)

![image](https://github.com/Shubhashree359/johnson_counter/assets/142501263/42235633-5ad5-4ea2-bc1f-31e36f5572e5)































































